#Synchronization 和对象锁
由Thomas Kotzmann 和 Christian Wimmer撰写

Java编程语言的一个优势之一便是它内置的对于多线程编程的支持。一个在多个线程间共享的对象可以被锁住来保证它的同步访问。Java对于指定关键代码域（被称为临界区）提供了原语，它作用在共享的对象上，并且使该对象在同一时间只能被一个线程操作。第一个进入临界区的线程锁住共享对象，当第二个线程想要进入该临界区时，它只能等到第一个线程释放了共享对象的锁才行。

Java HotSpot虚拟机，每个对象都有一个类指针和一个对象头字。对象头字里面存储了唯一的hash code，年龄和分代垃圾收集标志位，它也被用来实现轻量级锁原型。下面的图片展示了不同对象状态所对应的对象头字。

![](../images/Synchronization.gif)

图的右边说明了标准锁的过程，如果对象未被加锁，则最后两bit位为01，当对象被方法同步，对象头字和指向这个对象的指针会被存储在当前栈帧的锁记录中，然后虚拟机尝试通过CAS的操作在对象头字中安装一个指向锁记录的指针，如果成功，当前线程获取到锁。锁记录是位对其的，最后两bit位会变成00，标识对象被加锁了。

如果由于对象已经被别的线程加锁导致CAS操作失败，虚拟机会首先测试对象头字里的指针指向的方法栈是否是当前前程的，如果是，则线程已经拥有了对象锁，可以安全地继续操作。这样递归被加锁的对象，锁记录会被初始化为0而不是对象的头字。只有两个不同线程同时对同一对象进行同步操作，轻量级锁才会膨胀为重量级锁，来进来线程等待管理。

轻量级锁的代价比膨胀锁小很多，但是它们的性能都由于每个CAS操作都必须在多处理器上原子地被操作而受影响，尽管很多时候对象的加锁和释放锁的操作是同一线程在操作。在Java6，这个缺陷被称为store-free 偏向锁技术所解决，所用的概念与[Kawachiya02]类似。只有操作。当对象的身份hash值被访问（因为hash码位和线程ID位是共享的），偏向锁会被回收。

对象是明确设计为可以被多个线程共享的情况，比如生产者/消费者队列，就不适合偏向锁。因此，如果对于类的实例的偏向锁撤销操作频繁发生，则该类将禁用偏向锁。这被称为bulk revocation。如果在禁用了偏向锁的类实例上调用了加锁代码，它将执行标准的轻量级锁过程。最新分配的类实例对被标志为 **不可偏向的**。

一个类似的机理，称为bulk rebiasing, 用于在类对象被不同线程加锁、释放锁，但是从未同时发生的情况下进行优化，它使类所有实例的偏向无效，而不禁用偏向锁。类中的纪元值作为时间戳，标识偏向的有效性。在对象分配的时候会把这个值拷贝到对象头字，bulk rebiasing可以高效地被实现为适当类中的epoch增量，下次该类的实例被加锁时，代码探测到对象头字不同的值，并将对象重新偏向当前线程。

##源码
Synchronization影响了JVM很多部分：对象头字的结果定义在oopDesc and markOopDesc类中，轻量级锁的代码集成在解释器和编译器中，ObjectMonitor类代表了膨胀锁。偏向锁集中在BiasedLocking。可以通过标志位开启：`-XX:+UseBiasedLocking and disabled via -XX:-UseBiasedLocking`. Java6和7默认是开启的，但仅在应用启动几秒后激活。因此，在跑micro-benchmarks前，通过标志位`-XX:BiasedLockingStartupDelay=0`来关掉延迟。
